import config
from binance.client import Client
from datetime import datetime
import mysql.connector
import decimal
import time

# structure of ticker_price_dict = {"BTC":{"price":12345.67, "decimal_place":2}}
ticker_price_dict= {}
base_sql_price = "INSERT INTO price_table (id, time, symbol, usdt_price, digits) VALUES (0, NOW(),"
base_sql_order = "INSERT INTO order_table (order_id, place_time, symbol, order_price, order_quant, direction, is_filled, filled_price) VALUES ("


def insert_price_to_mysql(symbol, price, precision):
    # time_stamp = timestamp / 1000
    symbol = symbol
    price = price
    precision = precision
    sql_price = base_sql_price + "'" + symbol +"' ,"+str(price)+","+str(precision)+")"
    # print(sql_price)
    return sql_price


def insert_order_to_mysql(order_id, place_time, symbol, order_price, order_quant, direction, is_filled, filled_price):
    order_id=order_id
    place_time= str(place_time/1000)
    symbol=symbol
    order_price=order_price
    order_quant=order_quant
    direction=direction
    is_filled=is_filled
    filled_price=filled_price
    sql_order= base_sql_order + str(order_id) +", FROM_UNIXTIME(" + place_time + "), '" + symbol +"', "+str(order_price)+","+str(order_quant)+", '"+direction+"', '" + is_filled + "', " + str(filled_price) + ");"
    print(sql_order)
    return sql_order

# The base endpoint is: https://api.binance.com
# 0. Get current time
begin_time = datetime.now()
current_time = begin_time.strftime("%H:%M:%S")

# 1. Connect to Binance
client = Client(config.api_key, config.api_secret)
print("Connected to Binance...", "Current Time =", current_time)

while True:
    # 2. Update the symbols (xxx/usdt) available to trade
    # 2.1 get all tickers
    all_tickers = client.get_all_tickers()
    # 2.2 get tickers ending with USDT
    if ticker_price_dict== {}:
        for i in all_tickers:
            symbol_str = i['symbol']
            if symbol_str[-4:] == "USDT":
                price_str = i["price"]
                decimal_places = abs(decimal.Decimal(price_str.rstrip('0')).as_tuple().exponent)
                ticker_price_dict[symbol_str[:-4]]={"price": float(price_str), "decimal_places": decimal_places}
    else:
        for i in all_tickers:
            symbol_str = i['symbol']
            if symbol_str[-4:] == "USDT":
                price_str = i["price"]
                symbol_str = symbol_str[:-4]
                new_digits = abs(decimal.Decimal(price_str.rstrip('0')).as_tuple().exponent)
                try:
                    old_digits = ticker_price_dict[symbol_str]["decimal_places"]
                    if new_digits > old_digits:
                        ticker_price_dict[symbol_str]["decimal_places"]=new_digits
                        print("***Digits changed! ", symbol_str, " Old: ", old_digits, " New: ", new_digits)
                except:
                    ticker_price_dict[symbol_str]={"price": float(price_str), "decimal_places": new_digits}

    # 3.Save data to database
    cnx = mysql.connector.connect(user=config.mysql_user, password=config.mysql_password, host=config.host, database=config.database)
    cursor = cnx.cursor()
    for price_symbol in ticker_price_dict.keys():
        symbol_dict = ticker_price_dict[price_symbol]
        price_float = symbol_dict["price"]
        price_digits = symbol_dict['decimal_places']
        cursor.execute(insert_price_to_mysql(price_symbol, price_float, price_digits))
    # cursor.execute(insert_order_to_mysql(1504749752, 1653832559259, "LUNA", 0.00012, 190030, "BUY", "No", 0.00))
    cnx.commit()

    cnx.close()

    # 4. Get balance and open order information
    free_usdt = client.get_asset_balance(asset='USDT')["free"]
    print(free_usdt)

    # 5. Signal for buy or sell

    # 6. Get all current open orders
    orders = client.get_open_orders()
    print(orders)

    # 7. Calculate time duration for one round.
    end_time = datetime.now()
    duration = end_time - begin_time
    print("Round duration: ", duration)
    time.sleep(30)

    # 7. Place buy or sell order

    # 8. Monitoring Order status

